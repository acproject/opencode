# 自定义 Tool Runtime（含 LSP）旁路式嵌入：开发计划

目标：在不破坏现有 opencode 行为的前提下，引入可选的“自定义 Tool Runtime（含 LSP）”，让推理引擎只负责推理；opencode 以旁路方式集成新引擎与新 Runtime，并可通过 Feature Flag 控制启用。

## 当前进度

- 已实现 Tool 执行入口隔离：在工具执行处引入 ToolRuntime 分发（默认 direct）
- 已实现 LangChain Tool Runtime（旁路包装）：按需动态加载 @langchain/core/tools，不影响默认构建
- 已补齐取消/中断透传：Tool.Context.abort 透传到 LangChain invoke 的 signal
- 已实现 Provider 扩展注册点：通过 ProviderExtensions 追加 custom loader（不改变默认 provider 行为）
- 已实现编排入口骨架隔离：新增 OrchestratorRuntime 并接入 SessionProcessor（默认 direct；LangChain 编排器为占位）

## 设计原则

- Zero Behavior Change：默认配置与默认环境变量下，行为与输出保持一致
- 入口隔离：把“推理/编排入口”从现有路径抽象出来，允许选择不同 Runtime
- Provider 扩展而非修改：新增扩展点（注册/装配机制），不改动既有 Provider 行为
- Runtime 自包含：LangChain Runtime 的依赖、桥接、工具绑定、上下文适配都在独立目录内完成
- Feature Flag 控制：只靠环境变量/配置开关启用，便于灰度与回滚
- Tool 接口桥接：opencode ToolRegistry 保持不变，对外暴露一层桥接，让 Runtime 可替换

## 分阶段里程碑

### M0：骨架与零行为变化（已落地）

- 新增 ToolRuntime 抽象与默认 direct runtime
- 在 tool 执行入口处引入 runtime 分发，但默认仍走 direct
- 新增 Feature Flag：OPENCODE_EXPERIMENTAL_LANGCHAIN_TOOL_RUNTIME（默认关闭）

验收标准：

- 未设置 OPENCODE_EXPERIMENTAL_LANGCHAIN_TOOL_RUNTIME 时，所有工具调用路径与结果一致

### M1：LangChain Tool Runtime（旁路执行器）

范围：

- 通过 LangChain 的 tool() 形式包装 opencode 工具并执行
- 将 opencode Tool.Context 作为 LangChain runtime context 传递
- 依赖缺失时给出明确错误提示（不会影响默认路径）

验收标准：

- 开启 OPENCODE_EXPERIMENTAL_LANGCHAIN_TOOL_RUNTIME 后，基础工具（read/grep/glob/edit/write）可被正常调用并回填输出

### M2：入口隔离（编排层）

范围：

- 抽象“Agent 编排入口”（当前 SessionProcessor + LLM.stream）为可切换 Runtime（骨架已落地）
- 默认仍使用现有 AI SDK streaming + toolcall 路径
- LangChain Runtime 作为可选编排器：负责工具选择/多步执行；推理引擎只做生成

验收标准：

- 默认路径行为不变
- 可通过 Feature Flag 切换“编排器”（OPENCODE_EXPERIMENTAL_LANGCHAIN_ORCHESTRATOR）
- 开启编排器开关后，仍能完成一次完整的 toolcall 循环（当前仅骨架占位，仍走原 LLM.stream；多步编排后续引入）

### M3：Provider 扩展点（注册式）

范围：

- 增加 Provider Loader/Adapter 的注册机制
- LangChain Runtime 可复用现有 Provider 的推理能力，或引入额外推理后端适配

验收标准：

- 新 Provider/Adapter 的接入不需要修改 provider.ts 的核心逻辑

### M4：Tool Bridge + LSP 强化

范围：

- Tool 接口桥接层补齐：结构化 schema、附件、增量 metadata 更新
- LSP 生命周期与 LangChain Runtime 绑定：按需启动、复用、回收

验收标准：

- LangChain Runtime 下 LSP tool 工作正常，并能在多步链路中稳定复用

## 下一步（建议按顺序）

- 完成 M1 验收：在开启 OPENCODE_EXPERIMENTAL_LANGCHAIN_TOOL_RUNTIME 的情况下覆盖基础工具集调用路径
- 推进 M2：将 LangChain 编排器实现为可选路径（生成/解析/多步执行），并保持事件与 SessionProcessor 兼容
- 推进 M4：在 LangChain 编排器路径下做 LSP 生命周期复用与回收策略

### M5：AutoGen（可选探索）

范围：

- 在既有 Runtime 抽象上新增 AutoGen 编排器实验实现
- Feature Flag 控制，保持旁路

## 风险与约束

- 依赖体积：LangChain 依赖可能较重，需要确保仅在启用时加载
- 工具权限：必须复用 PermissionNext 机制，避免绕过
- 输出一致性：不同编排器可能导致 tool 调用顺序变化，需要明确边界与回归用例


### 最新进展已经后续工作
后续工作怎么做（建议顺序）

- 先把 Terminal 体验补齐（最快提升体感）
  - Web/桌面端：继续用 ghostty-web （你们已经在用且有补丁），把“会话级 cwd/目录切换”作为一等能力：让 pty.create 支持传入 cwd 或在 /pty/:id/connect 支持切换目录的协议（现在前端传了 ?directory= ，但服务端 connect 路由没消费这个参数）。
  - TUI 端：短期继续文本输出没问题；如果要“更像真终端”，可考虑把 TUI 的 Terminal 工具改成“可展开的实时流式输出 + 复制/搜索/清屏/保存 buffer”，先做信息架构增强，不急着嵌入完整终端模拟器。
- 再补齐 M1 验收与回归
  - 开启 OPENCODE_EXPERIMENTAL_LANGCHAIN_TOOL_RUNTIME 的情况下，跑一遍“基础工具集”全链路：参数校验、权限、abort、中途 metadata 回填、错误回填一致性。
- 推进 M2：真正的可选编排器
  - 目标是把“多步工具选择/执行循环”从当前 LLM.stream 路径抽出来，LangChain 编排器负责：生成 → 解析 toolcall → 执行 tool → 把结果喂回 → 继续，且事件/parts 结构保持兼容。
- 最后做 M4：把 LSP 生命周期绑定到编排器
  - 有了多步编排后，LSP 才有稳定的“会话级复用/回收”落点（否则只是工具层单点调用，收益有限）。


### 新的问题以及需要开发的新特性
- Unknown tool: editFile
- 模型不能按照上下文进行工作
- 需要增加编辑器
- 添加本地MCP服务的能力
